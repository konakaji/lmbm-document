# MODatasetデータ構造の詳細分析

## 概要

`MODataset`は、量子化学計算結果を機械学習で処理可能な形式に変換したデータセットです。本ドキュメントでは、10個の分子データに対する実際のデータ構造を詳細に分析し、各データの形状と意味を説明します。

## データの種類と形状

### 1. 原子座標データ

#### `atom_positions.pt`
- **形状**: `[n_atoms, 3]`
- **意味**: 各原子の3次元座標（Angstrom単位）
- **データ型**: `torch.float32`

| 分子ID | 形状 | 原子数 | 例 |
|--------|------|--------|-----|
| 0 | `[5, 3]` | 5 | メタン |
| 1 | `[8, 3]` | 8 | エタン |
| 2 | `[6, 3]` | 6 | エチレン |
| 3 | `[4, 3]` | 4 | アセチレン |
| 4 | `[9, 3]` | 9 | プロパン |
| 5 | `[7, 3]` | 7 | プロピレン |
| 6 | `[9, 3]` | 9 | プロパン |
| 7 | `[9, 3]` | 9 | プロパン |
| 8 | `[11, 3]` | 11 | プロパン |
| 9 | `[9, 3]` | 9 | プロパン |

### 2. 原子種データ

#### `atom_type.pt`
- **形状**: `(n_atoms,)`
- **意味**: 各原子の原子種インデックス
- **データ型**: `numpy.ndarray`

**原子種インデックス**:
- 0: H (水素)
- 1: S (硫黄)
- 2: Li (リチウム)
- 3: Be (ベリリウム)
- 4: B (ホウ素)
- 5: C (炭素)
- 6: N (窒素)
- 7: O (酸素)
- 8: F (フッ素)

### 3. 分子軌道データ

#### `mo_embeddings_canonical_original.pt`
- **形状**: `[n_mo, n_atoms, 18]`
- **意味**: 各分子軌道の各原子への埋め込みベクトル
- **データ型**: `torch.float32`

| 分子ID | 形状 | 分子軌道数 | 原子数 | 特徴次元 |
|--------|------|------------|--------|----------|
| 0 | `[34, 5, 18]` | 34 | 5 | 18 |
| 1 | `[58, 8, 18]` | 58 | 8 | 18 |
| 2 | `[48, 6, 18]` | 48 | 6 | 18 |
| 3 | `[38, 4, 18]` | 38 | 4 | 18 |
| 4 | `[72, 9, 18]` | 72 | 9 | 18 |
| 5 | `[62, 7, 18]` | 62 | 7 | 18 |
| 6 | `[72, 9, 18]` | 72 | 9 | 18 |
| 7 | `[72, 9, 18]` | 72 | 9 | 18 |
| 8 | `[82, 11, 18]` | 82 | 11 | 18 |
| 9 | `[72, 9, 18]` | 72 | 9 | 18 |

**特徴次元18の構成**:
- E3NN既約表現: `4x0e+3x1o+1x2e`
- 計算: 4×1 + 3×3 + 1×5 = 18次元
- 軌道寄与のみ（エネルギー情報は別途保存）

#### `mo_energies.pt`
- **形状**: `[n_mo]`
- **意味**: 各分子軌道のエネルギー（Hartree単位）
- **データ型**: `torch.float32`

### 4. CCSD振幅データ

#### `t1_ccsd_canonical.pt`
- **形状**: `[n_oc, n_vi]`
- **意味**: CCSD T1振幅（正準軌道）
- **データ型**: `torch.float32`

| 分子ID | 形状 | 占有軌道数 | 空軌道数 |
|--------|------|------------|----------|
| 0 | `[5, 29]` | 5 | 29 |
| 1 | `[9, 49]` | 9 | 49 |
| 2 | `[8, 40]` | 8 | 40 |
| 3 | `[7, 31]` | 7 | 31 |
| 4 | `[13, 59]` | 13 | 59 |
| 5 | `[12, 50]` | 12 | 50 |
| 6 | `[13, 59]` | 13 | 59 |
| 7 | `[12, 60]` | 12 | 60 |
| 8 | `[13, 69]` | 13 | 69 |
| 9 | `[12, 60]` | 12 | 60 |

#### `t2_ccsd_canonical.pt`
- **形状**: `[n_oc, n_oc, n_vi, n_vi]`
- **意味**: CCSD T2振幅（正準軌道）
- **データ型**: `torch.float32`

### 5. 幾何学的データ（geo_data）

#### `geo_data.pos`
- **形状**: `[n_mo × n_atoms, 3]`
- **意味**: 各分子軌道に対してブロードキャストされた原子座標
- **データ型**: `torch.float32`

| 分子ID | 形状 | 計算 |
|--------|------|------|
| 0 | `[170, 3]` | 34 × 5 = 170 |
| 1 | `[464, 3]` | 58 × 8 = 464 |
| 2 | `[288, 3]` | 48 × 6 = 288 |
| 3 | `[152, 3]` | 38 × 4 = 152 |
| 4 | `[648, 3]` | 72 × 9 = 648 |
| 5 | `[434, 3]` | 62 × 7 = 434 |
| 6 | `[648, 3]` | 72 × 9 = 648 |
| 7 | `[648, 3]` | 72 × 9 = 648 |
| 8 | `[902, 3]` | 82 × 11 = 902 |
| 9 | `[648, 3]` | 72 × 9 = 648 |

#### `geo_data.edge_index`
- **形状**: `[2, n_edges]`
- **意味**: エッジの接続情報（ソース→ターゲット）
- **データ型**: `torch.long`

| 分子ID | 形状 | エッジ数 | 計算 |
|--------|------|----------|------|
| 0 | `[2, 680]` | 680 | 20 × 34 = 680 |
| 1 | `[2, 3248]` | 3248 | 56 × 58 = 3248 |
| 2 | `[2, 1440]` | 1440 | 30 × 48 = 1440 |
| 3 | `[2, 456]` | 456 | 12 × 38 = 456 |
| 4 | `[2, 5184]` | 5184 | 72 × 72 = 5184 |
| 5 | `[2, 2604]` | 2604 | 42 × 62 = 2604 |
| 6 | `[2, 5184]` | 5184 | 72 × 72 = 5184 |
| 7 | `[2, 5184]` | 5184 | 72 × 72 = 5184 |
| 8 | `[2, 9020]` | 9020 | 110 × 82 = 9020 |
| 9 | `[2, 5184]` | 5184 | 72 × 72 = 5184 |

#### `geo_data.length`
- **形状**: `[n_edges, 1]`
- **意味**: 各エッジの距離（Angstrom単位）
- **データ型**: `torch.float32`

#### `geo_data.vector`
- **形状**: `[n_edges, 3]`
- **意味**: 各エッジの方向ベクトル（正規化されていない）
- **データ型**: `torch.float32`

#### `geo_data.vector`の詳細分析

**計算方法**:
```python
vectors = positions[receiver] - positions[sender]
```
- **receiver**: エッジの終点原子
- **sender**: エッジの始点原子
- **正規化**: されていない（距離情報を含む）

**物理的意味**:
- **方向**: エッジの方向を表す
- **距離**: ベクトルの長さがエッジの距離と同じ
- **座標系**: 3次元直交座標系（Angstrom単位）

**具体例（分子0のメタン）**:
```
エッジ0: 原子1(H) -> 原子0(C)
  ベクトル: (-1.092, -0.000, -0.008)
  距離: 1.092 Å
  意味: 原子1から原子0への方向ベクトル

エッジ1: 原子2(H) -> 原子0(C)
  ベクトル: (0.364, -1.029, -0.008)
  距離: 1.092 Å
  意味: 原子2から原子0への方向ベクトル
```

**重要な特徴**:
- **正規化されていない**: 距離情報を保持
- **方向と距離の統合**: 1つのベクトルで両方を表現
- **E3NN互換**: 等変ニューラルネットワークで処理可能
- **効率的な格納**: 方向と距離を別々に格納する必要がない
- **ブロードキャスト**: 各分子軌道に対して同じベクトルが複製される

#### `geo_data.one_hot`
- **形状**: `[n_mo × n_atoms, 9]`
- **意味**: 原子種のone-hotエンコーディング
- **データ型**: `torch.float32`

| 分子ID | 形状 | 計算 |
|--------|------|------|
| 0 | `[170, 9]` | 34 × 5 = 170 |
| 1 | `[464, 9]` | 58 × 8 = 464 |
| 2 | `[288, 9]` | 48 × 6 = 288 |
| 3 | `[152, 9]` | 38 × 4 = 152 |
| 4 | `[648, 9]` | 72 × 9 = 648 |
| 5 | `[434, 9]` | 62 × 7 = 434 |
| 6 | `[648, 9]` | 72 × 9 = 648 |
| 7 | `[648, 9]` | 72 × 9 = 648 |
| 8 | `[902, 9]` | 82 × 11 = 902 |
| 9 | `[648, 9]` | 72 × 9 = 648 |

### 6. スムーズ距離行列

#### `smooth_distance`
- **形状**: `[n_atoms, n_atoms]`
- **意味**: 原子間のスムーズな重み行列
- **データ型**: `torch.float32`

| 分子ID | 形状 | 原子数 |
|--------|------|--------|
| 0 | `[5, 5]` | 5 |
| 1 | `[8, 8]` | 8 |
| 2 | `[6, 6]` | 6 |
| 3 | `[4, 4]` | 4 |
| 4 | `[9, 9]` | 9 |
| 5 | `[7, 7]` | 7 |
| 6 | `[9, 9]` | 9 |
| 7 | `[9, 9]` | 9 |
| 8 | `[11, 11]` | 11 |
| 9 | `[9, 9]` | 9 |

#### `smooth_distance`の詳細分析

**計算方法**:
```python
# 1. radius_graphでエッジを取得（自己ループ含む）
edge_index = radius_graph(pos, r=max_radius, max_num_neighbors=max_neighbor, loop=True)

# 2. 原子間距離を計算
distances = (pos[row] - pos[col]).norm(dim=1)

# 3. soft_unit_step関数を適用
edge_weight = soft_unit_step(10 * (1 - distances / max_radius))

# 4. スパース行列から密行列に変換
edge_weight_matrix = torch.sparse_coo_tensor(edge_index, edge_weight, (n_atom, n_atom))
smooth_distance = edge_weight_matrix.to_dense()
```

**物理的意味**:
- **自己ループ**: 0.9048（最大値）
- **近距離原子**: 0.8799（C-H結合、1.092 Å）
- **中距離原子**: 0.8560（H-H相互作用、1.783 Å）
- **遠距離原子**: 0.0（最大半径5.0 Åを超える場合）

**重み関数の特徴**:
- **距離0**: 重み ≈ 1.0
- **距離 = max_radius**: 重み ≈ 0.0
- **スムーズな減衰**: 急激な変化を避ける

**具体例（分子0のメタン）**:
```
smooth_distance行列:
     C    H1   H2   H3   H4
C  [0.905, 0.880, 0.880, 0.880, 0.880]
H1 [0.880, 0.905, 0.856, 0.856, 0.856]
H2 [0.880, 0.856, 0.905, 0.856, 0.856]
H3 [0.880, 0.856, 0.856, 0.905, 0.856]
H4 [0.880, 0.856, 0.856, 0.856, 0.905]
```

**用途**:
- **重み付け**: 原子間の相互作用の重要度を表現
- **近傍の影響**: 近い原子ほど大きな影響を与える
- **スムーズな減衰**: 急激な境界を避ける
- **E3NNでの処理**: 等変性を保ちながら局所的な相互作用を適切に重み付け

## データの関係性

### 1. 分子軌道と原子の関係
- **分子軌道数**: 基底関数数に依存
- **原子数**: 分子の構成原子数
- **特徴次元**: 18（E3NN既約表現）

### 2. エッジ情報の構造
- **軌道ごとのエッジ**: 各軌道で同じ原子間結合構造
- **エッジのブロードキャスト**: 軌道数 × 軌道0のエッジ数
- **原子インデックスのオフセット**: 軌道ごとに `n_atoms` ずつ増加

### 3. データの依存関係
- **geo_data**: atom_positions, atom_type, mo_embeddingsから生成
- **エッジ数**: 原子数と結合半径に依存
- **CCSD振幅**: 占有軌道数と空軌道数に依存

## 機械学習での使用

### 1. 入力データ
- **原子座標**: `geo_data.pos`
- **原子種**: `geo_data.one_hot`
- **分子軌道**: `mo_embeddings`
- **エッジ情報**: `geo_data.edge_index`, `geo_data.length`, `geo_data.vector`

### 2. ターゲットデータ
- **CCSD振幅**: `t1_ccsd_canonical`, `t2_ccsd_canonical`
- **分子軌道エネルギー**: `mo_energies`

### 3. E3NN互換性
- **等変性**: 回転・並進・置換に対して等変
- **グラフ構造**: PyTorch GeometricのData形式
- **バッチ処理**: 異なるサイズの分子を統一的に処理

## まとめ

`MODataset`のデータ構造は以下の特徴を持ちます：

1. **多様性**: 異なるサイズの分子を統一的に処理
2. **完全性**: 量子化学計算の全情報を保持
3. **効率性**: E3NNで効率的に処理可能な形式
4. **拡張性**: 新しい分子や計算手法に対応可能

このデータ構造により、分子の幾何学的構造、電子構造、および量子化学計算結果を統合的に機械学習で処理できます。
